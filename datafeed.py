import re
import asyncio
import time
import requests
import websockets
from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor(max_workers=1)
LOCDICT, PREFIXES, LENGTH = {}, ('cs_', 'qs_'), 3000

CUR = 'BITSTAMP:BTCUSD'
LOGGER = None


# change this to any exchange.On a chart in the website scrape the link on the search bar like, for example this link ->
#     https://www.tradingview.com/chart/?symbol=BINANCE%3ABTCUSDT
#     CUR='BINANCE:BTCUSD'


def format_messages(update=False):
    global LENGTH
    time_dict = {'1_minute': '1', '3_minutes': '3', '5_minutes': '5', '15_minutes': '15',
                 '30_minutes': '30', '45_minutes': '45', '1_hour': '1H', '2_hours': '2H',
                 '3_hours': '3H', '4_hours': '4H', '1_day': '1D', '1_week': '1W', '1_month': '1M'}
    if update:
        for x, j in time_dict.items():
            print('Enter', j + ' ' * 5 + 'for  ' + x)
        _ = input()
        if _ not in time_dict.values():
            LOGGER.critical(f"your choice '{_}' is not in {tuple(time_dict.values())}, defaulting to 1M.")
            _ = '1'
        length = LENGTH
        try:
            length = int(input(f'how many bars of {[k for k, v in time_dict.items() if v == _][0]}? >100 & <10000 '))
            length = length if 100 < length < 10000 else 300
        except ValueError:
            LOGGER.critical(f'Wrong choice,expected integer got {length}, defaulting to {LENGTH}')
        time_dict = str(_)
        LENGTH = length
    else:
        time_dict = '1'
    msg = open('messages', 'r').read().strip().split('\n')
    messages = list(
        map(lambda each: re.sub("LENGTH", str(LENGTH), re.sub("TIME_DICT", time_dict, re.sub("CUR", CUR, each))), msg))
    return messages


def format_ws_msgs(specify):
    """Adds the length of the message between some prefix"""
    msg = format_messages(specify)
    msg = list(map(parse_ws_message, msg))
    if not msg[0]:
        return None
    return tuple(map(lambda x: f'~m~{len(x[x.find("~{") + 1:])}~m~{x[x.find("~{") + 1:]}', msg))


def get_auth_token():
    username, password = (input(f'{x} ') for x in ('username', 'password'))
    data = {"username": {username}, "password": {password}, "remember": "off"}
    try:
        _ = requests.post(url='https://www.tradingview.com/accounts/signin/', data=data,
                          headers={'Referer': 'https://www.tradingview.com'}).json()['user']['auth_token']
        return _
    except requests.exceptions.ConnectionError as e:
        LOGGER.critical(str(e))
        return None
    except KeyError as e:
        if 'user' in str(e):
            LOGGER.critical('wrong password or username')
        return None


def rand_12(prefix):
    """generates prefix+random 12-character string"""
    from string import ascii_lowercase as letters
    from random import choice
    random_string = [''.join(choice(letters) for _ in range(12))][0]
    return prefix + random_string


def parse_ws_message(msg):
    """parses the message and adds the random character generated by rand_12().It also adds auth key"""
    loc1 = [re.search(f'{x}.+?"', msg) for x in PREFIXES]
    if loc1[0] and loc1[1] is not None or loc1[0] == loc1[1]:
        auth_token = get_auth_token()
        if auth_token is None:
            return None
        return msg.replace('unauthorized_user_token', auth_token)
    match, prefix = (loc1[0], PREFIXES[0]) if loc1[0] is not None else (loc1[1], PREFIXES[1])
    span = match.span()
    match = match.group(0)[:-1]
    if match in LOCDICT.values():
        key = [k for k, v in LOCDICT.items() if v == match][0]
    else:
        LOCDICT[key := rand_12(prefix)] = match
    if len(key) == len(match):
        msg = msg.replace(match, key)
    elif 'snapshoter' in match:
        msg = msg.replace(msg[span[1] - 14:span[1] - 1], key[2:])
    else:
        raise Exception(f'length of common session random in {msg} does not match')
    return msg


def queue_get_block(queue):
    while 1:
        try:
            return queue.get_nowait()
        except asyncio.queues.QueueEmpty:
            time.sleep(1)


def send(msg, S):
    S.send(msg)
    if not S.recv():
        S.close()
        return 1


def format_text(queue, S, session_rand):
    global LENGTH
    pattern = r'"v":\[((.+?,){5})'
    _ = queue_get_block(queue)
    try:
        g_list = re.search('","s":\[(.+?)\],"?', _).group(1).split('},{')
        g_list = (tuple(map(lambda spl: re.search(pattern, spl).group(1).rstrip(',').split(','), g_list)))
        if send(g_list, S):
            return
        while 1:
            msg = queue_get_block(queue)
            msg = msg.split('~m~{"m":"du",')
            _ = f'"p":["{session_rand}",{{"sds_1":{{"s":[{{"i":{LENGTH}'
            for x in msg:
                if _ in x:
                    g_list = [re.search(pattern, x).group(1).split(',')[:-1]]
                    LENGTH += 1
                    if send(g_list, S):
                        return
    except TypeError as e:
        LOGGER.critical(str(e))
        return
    except AttributeError as e:
        print(pattern, _, '\n', e)
        return


class Tv:
    def __init__(self, S, logger, specify=False):
        global LOGGER
        LOGGER = logger
        self.msg = None
        self.ws = None
        self.msg_queue = asyncio.Queue(maxsize=1)
        self.start(S, specify)

    def start(self, S, specify):
        self.msg = format_ws_msgs(specify)
        if self.msg is None:
            S.send(0)
            return
        for session_rand in tuple(LOCDICT.keys()):
            if PREFIXES[0] in session_rand:
                loop = asyncio.new_event_loop()
                loop.run_until_complete(self.ws_connect(session_rand, loop, S))

    async def keep_sending(self):
        counter = 1
        while 1:
            suffix = f'~h~{counter}'
            whole = f'~m~{len(suffix)}~m~' + suffix
            await asyncio.sleep(10)
            await self.ws.send(whole)
            counter += 1

    async def recv_messages(self):
        while 1:
            try:
                await self.msg_queue.put(await self.ws.recv())
                LOGGER.debug('got a msg from the Websocket!')
            except asyncio.queues.QueueEmpty:
                pass

    async def ws_connect(self, session_rand, loop, S):
        loop.run_in_executor(executor, format_text, self.msg_queue, S, session_rand)
        # This thread does not die even after calling executor.shutdown or loop.close,lets put something in the
        # queue that'll cause an exception
        try:
            self.ws = await websockets.connect('wss://data.tradingview.com/socket.io/websocket',
                                               extra_headers={'Origin': 'https://www.tradingview.com'}, timeout=100)
        except Exception as e:
            LOGGER.critical(str(e))
            S.send(0)
            await self.msg_queue.put(-1)
            executor.shutdown(wait=False, cancel_futures=True, )
            return
        LOGGER.debug('Switching Protocols')
        _ = 1
        for x in self.msg:
            LOGGER.debug(x)
            await self.ws.send(x)
            msg = await self.ws.recv()
            if _:
                if '"s":[{"i":0' in msg:
                    await self.msg_queue.put(msg)
                    _ = 0
        t1 = asyncio.create_task(self.recv_messages())
        t2 = asyncio.create_task(self.keep_sending())
        try:
            await t1, t2
        except Exception as e:
            LOGGER.critical(str(e))
            await self.msg_queue.put(-1)
            return
